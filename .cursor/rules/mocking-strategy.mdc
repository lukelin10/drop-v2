---
description: 
globs: 
alwaysApply: false
---
---
description: "Mock-first testing strategy for Replit-hosted databases"
globs: ["**/*.test.ts", "**/*.test.tsx", "**/*.spec.ts", "**/*.spec.tsx"]
alwaysApply: true
---

# Mock-First Testing Strategy

You are implementing tests for an application using a Replit-hosted database. Since Replit provides a single database instance, you MUST use mocking to avoid data corruption.

## Critical Rule: NEVER Access Real Database in Tests

Always mock database operations. Direct database access in tests is FORBIDDEN.

## Repository Pattern (Required)

First, implement repository interfaces for all database operations:

```typescript
// src/repositories/interfaces/user.repository.interface.ts
export interface IUserRepository {
  findById(id: string): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  create(data: CreateUserDto): Promise<User>;
  update(id: string, data: UpdateUserDto): Promise<User>;
  delete(id: string): Promise<void>;
  findAll(): Promise<User[]>;
}
```

## Service Layer Testing

Always inject repositories into services and mock them in tests:

```typescript
// src/services/__tests__/user.service.test.ts
import { UserService } from '../user.service';
import { IUserRepository } from '@/repositories/interfaces';

describe('UserService', () => {
  let service: UserService;
  let mockRepo: jest.Mocked<IUserRepository>;

  beforeEach(() => {
    // Create mock repository
    mockRepo = {
      findById: jest.fn(),
      findByEmail: jest.fn(),
      create: jest.fn(),
      update: jest.fn(),
      delete: jest.fn(),
      findAll: jest.fn(),
    };

    service = new UserService(mockRepo);
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  it('should create user when email is unique', async () => {
    // Arrange
    const userData = { email: 'test@example.com', name: 'Test' };
    mockRepo.findByEmail.mockResolvedValue(null);
    mockRepo.create.mockResolvedValue({ id: '1', ...userData });

    // Act
    const result = await service.createUser(userData);

    // Assert
    expect(mockRepo.findByEmail).toHaveBeenCalledWith('test@example.com');
    expect(mockRepo.create).toHaveBeenCalledWith(userData);
    expect(result.email).toBe('test@example.com');
  });
});
```

## Component Testing with Mocked Services

```typescript
// src/components/__tests__/UserList.test.tsx
import { render, screen } from '@testing-library/react';
import { UserList } from '../UserList';
import { UserService } from '@/services/user.service';

jest.mock('@/services/user.service');

describe('UserList', () => {
  let mockUserService: jest.Mocked<UserService>;

  beforeEach(() => {
    mockUserService = {
      getAllUsers: jest.fn(),
      deleteUser: jest.fn(),
    } as any;

    (UserService as jest.Mock).mockImplementation(() => mockUserService);
  });

  it('should display users', async () => {
    // Arrange
    const users = [
      { id: '1', name: 'User 1', email: 'user1@test.com' },
      { id: '2', name: 'User 2', email: 'user2@test.com' },
    ];
    mockUserService.getAllUsers.mockResolvedValue(users);

    // Act
    render(<UserList />);

    // Assert
    expect(await screen.findByText('User 1')).toBeInTheDocument();
    expect(await screen.findByText('User 2')).toBeInTheDocument();
  });
});
```

## API Route Testing

```typescript
// src/api/__tests__/users.api.test.ts
import request from 'supertest';
import { app } from '@/app';
import { UserService } from '@/services/user.service';

jest.mock('@/services/user.service');

describe('Users API', () => {
  let mockUserService: jest.Mocked<UserService>;

  beforeEach(() => {
    mockUserService = {
      getAllUsers: jest.fn(),
      createUser: jest.fn(),
      deleteUser: jest.fn(),
    } as any;

    (UserService as jest.Mock).mockImplementation(() => mockUserService);
  });

  it('DELETE /api/users/:id should delete user', async () => {
    // Arrange
    mockUserService.deleteUser.mockResolvedValue(undefined);

    // Act & Assert
    await request(app)
      .delete('/api/users/123')
      .expect(204);

    expect(mockUserService.deleteUser).toHaveBeenCalledWith('123');
  });
});
```

## Test Data Factories

Always use factories for consistent test data:

```typescript
// src/test-utils/factories/user.factory.ts
export const createMockUser = (overrides: Partial<User> = {}): User => ({
  id: '1',
  email: 'test@example.com',
  name: 'Test User',
  createdAt: new Date('2024-01-01'),
  updatedAt: new Date('2024-01-01'),
  ...overrides,
});

export const createMockUsers = (count: number): User[] => 
  Array.from({ length: count }, (_, i) => 
    createMockUser({ id: `${i + 1}`, email: `user${i + 1}@test.com` })
  );
```

## Database Mock Setup

Add to setupTests.ts to prevent accidental database access:

```typescript
// src/setupTests.ts
// Block direct database access
jest.mock('@prisma/client', () => ({
  PrismaClient: jest.fn(() => {
    throw new Error('Direct database access not allowed in tests. Use mocked repositories.');
  }),
}));

// For other ORMs
jest.mock('@/db/client', () => {
  throw new Error('Direct database access not allowed in tests. Use mocked repositories.');
});
```

## Testing Async Operations

```typescript
it('should handle async operations', async () => {
  // For promises
  mockRepo.findById.mockResolvedValue(userData);
  
  // For errors
  mockRepo.findById.mockRejectedValue(new Error('Not found'));
  
  // For delayed responses
  mockRepo.findById.mockImplementation(() => 
    new Promise(resolve => setTimeout(() => resolve(userData), 100))
  );
});
```

## Common Patterns

### Testing Error Cases
```typescript
it('should handle not found error', async () => {
  mockRepo.findById.mockResolvedValue(null);
  
  await expect(service.getUser('123')).rejects.toThrow('User not found');
});
```

### Testing Side Effects
```typescript
it('should send email after user creation', async () => {
  const mockEmailService = { send: jest.fn() };
  const service = new UserService(mockRepo, mockEmailService);
  
  await service.createUser(userData);
  
  expect(mockEmailService.send).toHaveBeenCalledWith(
    expect.objectContaining({ to: userData.email })
  );
});
```

### Testing Transactions
```typescript
it('should rollback on error', async () => {
  mockRepo.create.mockResolvedValueOnce(user1);
  mockRepo.create.mockRejectedValueOnce(new Error('Failed'));
  
  await expect(service.createMultipleUsers([user1, user2]))
    .rejects.toThrow('Failed');
  
  // Verify rollback logic was called
  expect(mockRepo.delete).toHaveBeenCalledWith(user1.id);
});
```

## Rules Summary

1. ALWAYS mock repositories, NEVER access database directly
2. Use dependency injection for all services
3. Create interfaces for all repositories
4. Use factories for test data generation
5. Mock at the service level for component tests
6. Clear all mocks in afterEach
7. Test both success and error paths
8. Use TypeScript types for all mocks